#ifndef HISTOGRAM_H
#define HISTOGRAM_H

#include <vector>
#include <QDebug>
#include <QObject>
#include <map>
#include <set>
#include "qcustomplot/qcustomplot.h"

/**
 * @file Histogram.h
 * @author Anisimov D
 * @brief Заголовочный файл для описания класса гистограмм
 * @date 07.05.2024
 */


//! \brief Определение вспомогательного типа данных для номеров источников и сообщений
//! \details Этот тип данных представляет собой std::map.
//! Ключ - номер источника, значение - множество номеров сообщений.
using MsgNumbersMap = std::map<int, std::set<int>>;
Q_DECLARE_METATYPE(MsgNumbersMap);

//! \brief Пространство имён для классов и структур, необходимых для построения гистограмм.
namespace hst {

//! \brief Раннее определение класса для тестов класса гистограмм
class Test_Histogram;

const bool showDebugMessages = true;    //!< Когда включена выводит дополнительную информацию в qDebug()
const int legendRowCount = 10;          //!< Максимальное количество элементов в легенде в одном столбце
const double moveDelta = 0.01;          //!< Отображает, насколько подвинется график при передвижении, с помощью стрелочек
const double scaleCoeff = 1.01;         //!< Отображает, во сколько раз изменится диапазон осей при уменьшении масштаба
const double standartScale = 1.05;      //!< Начальный масштаб графика
const int statusNumberAccuracy = 2;     //!< Количество цифр после запятой в числах, отображаемых в полоске состояние(statusbar)
const double yTickStep = 1.0;           //!< Шаг меток на оси Oy

const int rangeR = 128;                 //!< Диапазон значений красного цвета
const int startR = 128;                 //!< Минимальное значение красного цвета
const int rangeG = 50;                  //!< Диапазон значение зелёного цвета
const int startG = 128;                 //!< Минимальное значение зелёного цвета
const int barAlpha = 170;               //!< Значение непрозрачности

const int penAlpha = 255;               //!< Значение непрозрачности границы
const double penWidth = 1.5;            //!< Ширина границы

//! \brief Структура, описывающая одно сообщение
struct Message {
    double value;   //!< Значение, полученное в сообщении
    int msgnum;     //!< Номер сообщения
};

//! \brief Структура, описывающая данные полученные из источника
struct Plot {
    std::vector<Message> messages;  //!< messages Сообщения из источника
    int sourcenum;                  //!< sourcenum Номер источника
};

//! \brief Структура, описывающая данные со всех полученных источников, а также значения для интервалов
struct AllPlotInfo
{
    double start = 0;                               //!< Начало интервалов
    double interval = 0;                            //!< Длина одного интервала

    std::vector<Plot> plots = std::vector<Plot>();  //!< Данные со всех полученных источников
};

class Interval;

//! \brief Класс, описывающий график гистограммы
class Histogram : public QWidget {
    Q_OBJECT
public:
        //! Конструктор виджета гистограммы
        //! \param parent Родительский виджет
        explicit Histogram(QWidget* parent = nullptr);

        //! Метод задания интервалов
        //! \param start Начало интервалов
        //! \param interval Длина одного интервала
        //! \details Задаёт значения интервалов на графике.
        //! Если в графике уже есть данные, перестроит график с новыми интервалами
        //! \exception std::runtime_error При неположительном значении длины интервала класс выбросит исключение
        void setIntervals(const double start, const double interval);

        //! Метод добавления данных из источника
        //! \param plotData Данные из источника
        //! \details Добавит новые данные и, если график уже построен, перестроит его
        //! \exception std::runtime_error Если не заданы значения интервалов, выбросит исключение
        void addPlot(const Plot plotData);

        //! Метод построения графика гистограммы
        //! \details Строит график гистограммы по построенным данным.
        //! Высота столбца отображает количество попавших в интервал значений сообщений.
        //! У столбцов генерируются случайные цвета.
        //! Метки на оси Ox соответствуют границами интервалов.
        //! В легенде имена отображают середину интервала.
        //! Добавляет взаимодействия с графиков: перетаскивание и масштабирование с помощью мыши,
        //! выбор элементов графика, выбор нескольких элементов графика при зажатой клавише Ctrl
        void drawHistogram();

        //! Деструктор
        virtual ~Histogram() Q_DECL_OVERRIDE;
    private:
        //! Метод для переопределения цветов образом
        //! \details Генерирует новые цвета в формате RGB.
        //! Диапазоны цветов зависят от констант и определяются так:
        //! R:[startR, startR + rangeR],
        //! G:[startG, startG + rangeG],
        //! B:[0, R].
        //! Прозрачность определяется константой barAlpha.
        void regenerateColors();

        //! Метод для пересчёта высот столбцов
        //! \param plotData Источник с данными, который нужно сравнить с добавленными для пересчёта высот столбцов
        //! \details Пересчитывает высоты столбцов при переопределении
        //! интервалов или добавлении данных из нового источника.
        void calculateIntervals(const Plot& plotData);

        bool isDrawn = false;                       //!< Переменная, которая показывает нарисован график или нет
        QVector<int> selectedBars = QVector<int>(); //!< Вектор, который хранит индексы выбранных на данный момент столбцов
        AllPlotInfo allData;                        //!< Структура, которая хранит в себе информацию о интервалах и источники с данными
        std::vector<Interval> intervals;            //!< Вектор интервалов

        QCustomPlot* customPlot = nullptr;          //!< Указатель на класс для отображения графиков
        QLabel* statusLabel = nullptr;              //!< Указатель на метку для полоски состояния
        QStatusBar* statusbar = nullptr;            //!< Указатель на полоску состояния для отображения информации о выделенных столбцах
        QVBoxLayout* layout;                        //!< Указатель на компоновщик внутри виджета гитограмм

        QMenu* contextMenu;             //!< Контекстное меню
        QAction* actScale;              //!< Действие для сброса масштаба
        QAction* actTable;              //!< Действие для отправления сигнала с выбранными данными
        QAction* actLegend;             //!< Действие для переключения видимости легенды
        QAction* actColors;             //!< Действие для перегенерации цветов

        friend class Test_Histogram;
    public slots:
        //! Слот для получения данных о выбранных столбцах
        //! \details Посылает сигнал dataSignal с данными о выбранных столбцах
        void getData();

    private slots:
        //! Слот для переключения видимости легенды
        void toggleLegend();

        //! Слот для сброса масштаба
        void resetScale();

        //! Слот, обрабатывающий изменение выбранных элементов графика
        //! \details При выбранных столбцах или элементах легенды
        //! добавляет в выбранные соответствующие им столбцы или элементы легенды.
        //! Если при создании класса был указан указатель на полоску состояния,
        //! то в ней отобразится информация о выбранном интервале
        //! Вызывается по сигналу QCustomPlot::selectionChangedByUser
        void selectionChanged();

        //! Слот, показывающий контекстное меню
        //! \param pos Позиция, на которой отобразится контекстное меню
        //! \details В контекстном меню, если выбраны какие-то столбцы,
        //! можно выбрать "Show table", который вызовет слот getData.
        //! Также можно выбрать "Reset scale", который сбросит масштаб графика, вызовом слота resetScale.
        //! Вызывается по сигналу QCustomPlot::customContextMenuRequested
        //! \note Вероятно временно: сигнал с данными ловится с помощью QSignalSpy и
        //! полученная информация выводится в qDebug
        void showMenu(const QPoint& pos);

        //! Метод для обработки ввода с клавиатуры
        //! \details Позволяет двигать график с помощью стрелок или клавиш WASD.
        //! Позволяет масштабировать графиг с помощью кнопок +, -.
        void keyPressEvent(QKeyEvent* event) override;
    signals:
        //! Сигнал, отправляющий данные о источниках и номерах сообщений
        //! \param msgnumbers Хранит источники сообщений и соответствующие им номера сообщений
        //! \details Посылается слотом getData.
        void dataSignal(MsgNumbersMap msgnumbers);
};

//! \brief Класс, описывающий один интервал на графике гистограммы
class Interval {
    public:
        //! Конструктор по умолчанию
        Interval() = default;
        //! Конструктор с параметрами
        //! \param point1 Значение одной границы интервала
        //! \param point2 Значение другой границы интервала
        //! \details Создаст интервал с границами point1 и point2
        //! \note Порядок параметров не важен
        Interval(double point1, double point2);
        //! Деструктор по умолчанию
        ~Interval() = default;

        //! Метод проверки нахождения значения в интервале
        //! \param val Значение
        //! \return Если значение находится в инервале возвращает true, иначе false
        //! \note При проверке левая граница интервала включается, правая - нет
        bool inInterval(double val) const;
        //! Метод добавления сообщения в интервал
        //! \param msg Сообщение
        //! \param sourcenum Источник сообщения
        //! \return Возвращает успешное или неуспешное добавление сообщения
        //! \details Добавляет сообщение в интервал, если значение Message::value в сообщении находится в границах интервала
        //! \note При попытке добавить сообщение с номером сообщения, который уже был ранее успешно добавлен метод ничего не сделает.
        //! Информация об этом выведется в qDebug.
        bool addMsg(Message msg, int sourcenum);
        //! Метод получения левой границы интервала
        //! \return Левая граница интервала
        double getStart() const;
        //! Метод получения правой границы интервала
        //! \return Правая граница интервала
        double getEnd() const;
        //! Метод получения длины интервала
        //! \return Длина интервала, то есть конец интервала - начало интервала
        double length() const;
        //! Метод получения количества сообщений
        //! \return Количество сообщений по всем источникам в интервале
        unsigned long long msgCount() const;
        //! Метод получения данных о номерах источников и номерах сообщений в интервале
        //! \return Номера источников и соответствующие им номера сообщений
        MsgNumbersMap getIntervalData() const;
    private:
        double start = 0;           //!< Начало интервала
        double end = 0;             //!< Конец интервала
        MsgNumbersMap msgnumbers;   //!< Данные о источниках и соответствующих им сообщениях
};

}

#endif // HISTOGRAM_H
